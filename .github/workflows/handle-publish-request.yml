name: Handle UPM Publish Request

on:
  repository_dispatch:
    types: [package_publish]
  workflow_dispatch:
    inputs:
      repository:
        description: 'Repository full name (e.g., The1Studio/TheOneFeature)'
        required: true
        type: string
      commit_sha:
        description: 'Commit SHA'
        required: true
        type: string
      commit_message:
        description: 'Commit message'
        required: false
        type: string
        default: 'No message'
      commit_author:
        description: 'Commit author'
        required: false
        type: string
        default: 'unknown'
      branch:
        description: 'Branch name'
        required: false
        type: string
        default: 'master'
      package_path:
        description: 'Package path (empty for auto-detection)'
        required: false
        type: string
        default: ''

env:
  UPM_REGISTRY: ${{ vars.UPM_REGISTRY || 'https://upm.the1studio.org/' }}
  AUDIT_RETENTION_DAYS: 90

jobs:
  publish-packages:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    env:
      # Use workflow_dispatch inputs if available, otherwise use repository_dispatch client_payload
      PAYLOAD_REPOSITORY: ${{ github.event.inputs.repository || github.event.client_payload.repository }}
      PAYLOAD_COMMIT_SHA: ${{ github.event.inputs.commit_sha || github.event.client_payload.commit_sha }}
      PAYLOAD_COMMIT_MESSAGE: ${{ github.event.inputs.commit_message || github.event.client_payload.commit_message }}
      PAYLOAD_COMMIT_AUTHOR: ${{ github.event.inputs.commit_author || github.event.client_payload.commit_author }}
      PAYLOAD_BRANCH: ${{ github.event.inputs.branch || github.event.client_payload.branch }}
      PAYLOAD_PACKAGE_PATH: ${{ github.event.inputs.package_path || github.event.client_payload.package_path }}

    steps:
      - name: Validate dispatch payload
        run: |
          echo "üì¶ Received publish request from: $PAYLOAD_REPOSITORY"
          echo "üìù Commit: $PAYLOAD_COMMIT_SHA"
          echo "üë§ Author: $PAYLOAD_COMMIT_AUTHOR"
          echo "üåø Branch: $PAYLOAD_BRANCH"

          # Validate required payload fields
          if [ -z "$PAYLOAD_REPOSITORY" ]; then
            echo "‚ùå Missing repository in payload"
            exit 1
          fi

          if [ -z "$PAYLOAD_COMMIT_SHA" ]; then
            echo "‚ùå Missing commit_sha in payload"
            exit 1
          fi

      - name: Clone target repository
        uses: actions/checkout@v4
        with:
          repository: ${{ env.PAYLOAD_REPOSITORY }}
          ref: ${{ env.PAYLOAD_COMMIT_SHA }}
          path: target-repo
          token: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          registry-url: ${{ vars.UPM_REGISTRY || 'https://upm.the1studio.org/' }}

      - name: Configure npm authentication
        run: |
          npm config set "//${{ vars.UPM_REGISTRY_HOST || 'upm.the1studio.org/' }}:_authToken" "${{ secrets.NPM_TOKEN }}"
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

      - name: Validate registry configuration
        run: |
          echo "üîç Validating registry configuration..."

          # Validate registry URL format
          if [[ ! "$UPM_REGISTRY" =~ ^https://[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/?$ ]]; then
            echo "‚ùå Invalid registry URL format: $UPM_REGISTRY"
            exit 1
          fi

          echo "‚úÖ Registry URL validated: $UPM_REGISTRY"

      - name: Registry health check
        run: |
          echo "üè• Checking registry health..."

          max_attempts=3
          attempt=1

          while [ $attempt -le $max_attempts ]; do
            if curl -sSf "$UPM_REGISTRY" > /dev/null 2>&1; then
              echo "‚úÖ Registry is healthy"
              exit 0
            fi

            echo "‚ö†Ô∏è  Health check attempt $attempt failed"
            if [ $attempt -lt $max_attempts ]; then
              echo "Retrying in 5 seconds..."
              sleep 5
            fi
            ((attempt++))
          done

          echo "‚ùå Registry health check failed after $max_attempts attempts"
          exit 1

      - name: Define helper functions
        id: helpers
        run: |
          cd target-repo

          # Create helper script for npm operations with retry logic
          cat > npm-helpers.sh << 'HELPER_EOF'
          #!/bin/bash

          npm_view_with_retry() {
            local max_attempts=5
            local attempt=1

            while [ $attempt -le $max_attempts ]; do
              if output=$(npm view "$@" --registry "$UPM_REGISTRY" 2>&1); then
                echo "$output"
                return 0
              fi

              if echo "$output" | grep -qi "rate limit\|429\|too many requests"; then
                local wait_time=$((2 ** attempt))
                echo "‚ö†Ô∏è  Rate limited, waiting ${wait_time}s..." >&2
                sleep "$wait_time"
                ((attempt++))
              else
                return 1
              fi
            done

            echo "‚ùå Failed after $max_attempts attempts" >&2
            return 1
          }

          npm_publish_with_retry() {
            local max_attempts=3
            local attempt=1

            while [ $attempt -le $max_attempts ]; do
              if npm publish "$@" --registry "$UPM_REGISTRY" 2>&1; then
                return 0
              fi

              echo "‚ö†Ô∏è  Publish attempt $attempt failed" >&2
              if [ $attempt -lt $max_attempts ]; then
                local wait_time=$((2 ** attempt))
                echo "Retrying in ${wait_time}s..." >&2
                sleep "$wait_time"
              fi
              ((attempt++))
            done

            return 1
          }

          export -f npm_view_with_retry
          export -f npm_publish_with_retry
          HELPER_EOF

          chmod +x npm-helpers.sh
          source npm-helpers.sh

          echo "‚úÖ Helper functions defined"

      - name: Detect and validate packages
        id: detect
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          cd target-repo
          source npm-helpers.sh

          echo "üîç Detecting changed packages..."

          # Store working directory for absolute paths
          WORK_DIR="$(pwd)"

          # Initialize tracking files
          echo "" > changed_packages.txt
          echo "" > published_packages.txt
          echo "" > skipped_packages.txt

          # Find all package.json files (excluding node_modules)
          package_files=$(find . -name "package.json" -not -path "*/node_modules/*" -not -path "*/.git/*")

          if [ -z "$package_files" ]; then
            echo "‚ö†Ô∏è  No package.json files found"
            echo "published=0" >> $GITHUB_ENV
            echo "skipped=0" >> $GITHUB_ENV
            exit 0
          fi

          # Check if specific package path provided in payload
          specific_package="$PAYLOAD_PACKAGE_PATH"

          if [ -n "$specific_package" ]; then
            echo "üì¶ Specific package requested: $specific_package"
            if [ ! -f "$specific_package" ]; then
              echo "‚ùå Specified package not found: $specific_package"
              exit 1
            fi
            package_files="$specific_package"
          fi

          published_count=0
          skipped_count=0

          # Process each package
          while IFS= read -r package_json; do
            [ -z "$package_json" ] && continue
            [ ! -f "$package_json" ] && continue

            echo ""
            echo "=================================================="
            echo "üì¶ Processing: $package_json"
            echo "=================================================="

            package_name=$(jq -r '.name // "unknown"' "$package_json")
            new_version=$(jq -r '.version // "0.0.0"' "$package_json")
            package_dir=$(dirname "$package_json")

            # Security validations
            if [[ "$package_name" =~ [^a-zA-Z0-9@/._-] ]]; then
              echo "‚ùå Package name contains dangerous characters: $package_name"
              echo "$package_name|SKIPPED|Invalid package name" >> "$WORK_DIR/skipped_packages.txt"
              skipped_count=$((skipped_count + 1))
              continue
            fi

            if [[ ! "$new_version" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.]+)?(\+[a-zA-Z0-9.]+)?$ ]]; then
              echo "‚ùå Invalid semver format: $new_version"
              echo "$package_name|SKIPPED|Invalid version format" >> "$WORK_DIR/skipped_packages.txt"
              skipped_count=$((skipped_count + 1))
              continue
            fi

            echo "üìã Package: $package_name"
            echo "üìå Version: $new_version"

            # AI-powered package.json validation
            if [ -n "$GEMINI_API_KEY" ]; then
              echo "ü§ñ Validating package.json with Gemini AI..."

              # Read package.json content
              PACKAGE_CONTENT=$(cat "$package_json")

              # Create validation prompt
              VALIDATION_PROMPT=$(cat <<'PROMPT_EOF'
You are validating a Unity Package Manager (UPM) package.json file.

Analyze this package.json and return a JSON response:

PACKAGE_JSON_CONTENT

Return ONLY valid JSON in this exact format:
{
  "valid": true/false,
  "issues": [{
    "severity": "critical"|"warning",
    "type": "syntax_error"|"missing_field"|"invalid_format",
    "field": "field_name",
    "message": "Description",
    "suggestion": "How to fix"
  }],
  "fixedContent": "corrected JSON content if auto-fixable",
  "summary": "Brief summary"
}

Focus on CRITICAL issues:
- JSON syntax errors (missing/trailing commas)
- Missing required fields (name, version, displayName, description, unity)
- Invalid formats (package name, semver, Unity version)
- Dependency issues

If fixable, provide corrected JSON in "fixedContent".
PROMPT_EOF
)

              # Replace placeholder with actual content
              VALIDATION_PROMPT="${VALIDATION_PROMPT//PACKAGE_JSON_CONTENT/$PACKAGE_CONTENT}"

              # Call Gemini API
              GEMINI_RESPONSE=$(curl -s -X POST \
                "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=$GEMINI_API_KEY" \
                -H "Content-Type: application/json" \
                -d "$(jq -n \
                  --arg prompt "$VALIDATION_PROMPT" \
                  '{
                    "contents": [{
                      "parts": [{"text": $prompt}]
                    }],
                    "generationConfig": {
                      "temperature": 0.1,
                      "maxOutputTokens": 2048
                    }
                  }')" 2>/dev/null || echo "")

              if [ -n "$GEMINI_RESPONSE" ]; then
                # Extract AI response
                AI_OUTPUT=$(echo "$GEMINI_RESPONSE" | jq -r '.candidates[0].content.parts[0].text // empty' 2>/dev/null || echo "")

                if [ -n "$AI_OUTPUT" ]; then
                  # Try to parse JSON from response (may be wrapped in markdown code blocks)
                  VALIDATION_RESULT=$(echo "$AI_OUTPUT" | sed -n '/^{/,/^}/p' | jq '.' 2>/dev/null || echo "")

                  if [ -n "$VALIDATION_RESULT" ]; then
                    IS_VALID=$(echo "$VALIDATION_RESULT" | jq -r '.valid // false')
                    ISSUES_COUNT=$(echo "$VALIDATION_RESULT" | jq -r '.issues | length' 2>/dev/null || echo "0")
                    CRITICAL_COUNT=$(echo "$VALIDATION_RESULT" | jq -r '[.issues[] | select(.severity == "critical")] | length' 2>/dev/null || echo "0")

                    if [ "$IS_VALID" = "false" ] && [ "$CRITICAL_COUNT" -gt 0 ]; then
                      echo "‚ö†Ô∏è  Validation found $CRITICAL_COUNT critical issue(s)"

                      # Check if auto-fix available
                      FIXED_CONTENT=$(echo "$VALIDATION_RESULT" | jq -r '.fixedContent // empty')

                      if [ -n "$FIXED_CONTENT" ]; then
                        echo "üîß Auto-fix available, creating PR..."

                        # Save validation results
                        echo "$VALIDATION_RESULT" > "$WORK_DIR/validation_${package_name//\//_}.json"

                        # Create fix branch
                        FIX_BRANCH="fix/package-json-validation-$(date +%Y%m%d-%H%M%S)"
                        git checkout -b "$FIX_BRANCH"

                        # Apply fix
                        echo "$FIXED_CONTENT" > "$package_json"

                        # Create PR
                        SUMMARY=$(echo "$VALIDATION_RESULT" | jq -r '.summary // "Package.json validation fixes"')
                        ISSUES_LIST=$(echo "$VALIDATION_RESULT" | jq -r '.issues[] | "- [\(.severity | ascii_upcase)] \(.field): \(.message)"' | head -10)

                        git add "$package_json"
                        git commit -m "fix(package.json): $SUMMARY

Auto-fix applied by Gemini AI validation

Issues fixed:
$ISSUES_LIST

Workflow: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

                        git push origin "$FIX_BRANCH"

                        PR_URL=$(gh pr create \
                          --title "üîß Fix package.json validation issues in $package_name" \
                          --body "## ü§ñ AI-Powered Package.json Validation

**Package:** \`$package_name\`
**Critical Issues:** $CRITICAL_COUNT
**Total Issues:** $ISSUES_COUNT

### Issues Fixed:
$ISSUES_LIST

### Summary:
$SUMMARY

---

**Validation Workflow:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

This PR was automatically created by Gemini AI validation. Please review the changes before merging." \
                          --label "automated" \
                          --label "bug" 2>&1 || echo "")

                        if [ -n "$PR_URL" ]; then
                          echo "‚úÖ PR created: $PR_URL"

                          # Try to enable auto-merge
                          gh pr merge "$PR_URL" --auto --squash 2>&1 || echo "‚ö†Ô∏è  Auto-merge not available"

                          # Save PR URL for Discord notification
                          echo "$package_name|$PR_URL" >> "$WORK_DIR/validation_prs.txt"
                        fi

                        # Switch back to original branch
                        git checkout -

                        echo "‚è≠Ô∏è  Skipping publish for now (fix PR created)"
                        echo "$package_name|SKIPPED|Validation fix PR created" >> "$WORK_DIR/skipped_packages.txt"
                        skipped_count=$((skipped_count + 1))
                        continue
                      else
                        echo "‚ùå Critical issues found but no auto-fix available"
                        echo "$package_name|SKIPPED|Validation failed (no auto-fix)" >> "$WORK_DIR/skipped_packages.txt"
                        skipped_count=$((skipped_count + 1))
                        continue
                      fi
                    elif [ "$ISSUES_COUNT" -gt 0 ]; then
                      echo "‚ö†Ô∏è  Found $ISSUES_COUNT warning(s) but no critical issues"
                      echo "Proceeding with publish..."
                    else
                      echo "‚úÖ Validation passed"
                    fi
                  fi
                fi
              fi
            else
              echo "‚ÑπÔ∏è  Gemini validation skipped (GEMINI_API_KEY not set)"
            fi

            # Check if version already exists
            if npm_view_with_retry "$package_name@$new_version" version 2>/dev/null; then
              echo "‚è≠Ô∏è  Version already published, skipping..."
              echo "$package_name|SKIPPED|Version already exists" >> "$WORK_DIR/skipped_packages.txt"
              skipped_count=$((skipped_count + 1))
              continue
            fi

            # Get latest version for rollback check
            latest_version=$(npm_view_with_retry "$package_name" version 2>/dev/null || echo "0.0.0")
            echo "üìä Latest published: $latest_version"

            # Version rollback prevention (using npx for semver comparison)
            if [ "$latest_version" != "0.0.0" ]; then
              if npx --yes semver "$new_version" -r "<$latest_version" 2>/dev/null; then
                echo "‚ùå Version rollback detected: $new_version < $latest_version"
                echo "$package_name|SKIPPED|Version rollback prevented" >> "$WORK_DIR/skipped_packages.txt"
                skipped_count=$((skipped_count + 1))
                continue
              fi
            fi

            # Package size check
            cd "$package_dir"
            package_size=$(du -sb . | cut -f1)
            package_size_mb=$((package_size / 1024 / 1024))

            if [ "$package_size_mb" -gt 50 ]; then
              echo "‚ö†Ô∏è  Large package detected: ${package_size_mb}MB"
              echo "Consider reducing package size or using .npmignore"
            fi

            # Publish package
            echo "üöÄ Publishing $package_name@$new_version..."

            if npm_publish_with_retry --access public; then
              echo "‚úÖ Successfully published $package_name@$new_version"
              echo "$package_name|$latest_version|$new_version|$package_dir" >> "$WORK_DIR/published_packages.txt"
              published_count=$((published_count + 1))
            else
              echo "‚ùå Failed to publish $package_name@$new_version"
              echo "$package_name|FAILED|Publish error" >> "$WORK_DIR/skipped_packages.txt"
              skipped_count=$((skipped_count + 1))
            fi

            cd - > /dev/null
          done <<< "$package_files"

          # Save counts to environment
          echo "published=$published_count" >> $GITHUB_ENV
          echo "skipped=$skipped_count" >> $GITHUB_ENV

          echo ""
          echo "=================================================="
          echo "üìä Summary"
          echo "=================================================="
          echo "‚úÖ Published: $published_count"
          echo "‚è≠Ô∏è  Skipped: $skipped_count"

      - name: Generate AI Changelogs
        if: env.published > 0
        continue-on-error: true  # Don't fail workflow if changelog generation fails
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          cd target-repo

          echo "üìù AI Changelog Generation"
          echo "=================================================="

          # Check if GEMINI_API_KEY is available
          if [ -z "$GEMINI_API_KEY" ]; then
            echo "‚ö†Ô∏è  GEMINI_API_KEY not set, skipping AI changelog generation"
            echo "‚ÑπÔ∏è  Changelogs can still be generated manually using scripts/generate-changelog.sh"
            exit 0
          fi

          # Download generate-changelog.sh script from UPMAutoPublisher
          echo "üì• Downloading changelog generation script..."
          curl -sSfL \
            "https://raw.githubusercontent.com/${{ github.repository }}/master/scripts/generate-changelog.sh" \
            -o generate-changelog.sh

          if [ ! -f generate-changelog.sh ]; then
            echo "‚ùå Failed to download generate-changelog.sh"
            exit 1
          fi

          chmod +x generate-changelog.sh
          echo "‚úÖ Script downloaded successfully"

          # Process each published package
          if [ ! -f published_packages.txt ] || [ ! -s published_packages.txt ]; then
            echo "‚ö†Ô∏è  No published packages found"
            exit 0
          fi

          changelog_success=0
          changelog_failed=0

          while IFS='|' read -r package_name old_version new_version package_dir; do
            [ -z "$package_name" ] && continue

            echo ""
            echo "üìù Generating changelog for $package_name..."
            echo "   $old_version ‚Üí $new_version"

            package_json="$package_dir/package.json"

            if [ ! -f "$package_json" ]; then
              echo "‚ùå package.json not found: $package_json"
              changelog_failed=$((changelog_failed + 1))
              continue
            fi

            # Run changelog generation
            if ./generate-changelog.sh "$package_json" "$old_version" "$new_version" "$GEMINI_API_KEY"; then
              echo "‚úÖ Changelog generated for $package_name"
              changelog_success=$((changelog_success + 1))
            else
              echo "‚ö†Ô∏è  Failed to generate changelog for $package_name"
              changelog_failed=$((changelog_failed + 1))
            fi

          done < published_packages.txt

          echo ""
          echo "=================================================="
          echo "üìä Changelog Generation Summary"
          echo "=================================================="
          echo "‚úÖ Success: $changelog_success"
          echo "‚ùå Failed: $changelog_failed"

          # If any changelogs were generated, commit and push
          if [ "$changelog_success" -gt 0 ]; then
            echo ""
            echo "üíæ Committing changelog updates..."

            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"

            # Stage all CHANGELOG.md files
            find . -name "CHANGELOG.md" -not -path "./Library/*" -not -path "./.git/*" -exec git add {} \; || true

            if git diff --staged --quiet; then
              echo "‚ö†Ô∏è  No changelog changes to commit"
            else
              # Commit with [skip ci] to avoid triggering another workflow
              git commit -m "docs: update changelogs for published packages [skip ci]" \
                -m "Auto-generated changelogs for $changelog_success package(s)" \
                -m "- Generated using Gemini AI" \
                -m "- Based on git commit history" \
                -m "- Follows Keep a Changelog format"

              # Push changes back to source repository
              echo "üì§ Pushing changelog updates..."

              # Use GH_PAT for authentication (required to push to source repo)
              git remote set-url origin "https://x-access-token:${{ secrets.GH_PAT }}@github.com/${{ env.PAYLOAD_REPOSITORY }}.git"

              # Push to the branch that triggered this workflow
              if git push origin HEAD:${{ env.PAYLOAD_BRANCH }}; then
                echo "‚úÖ Changelogs pushed successfully"
              else
                echo "‚ùå Failed to push changelogs"
                exit 1
              fi
            fi
          fi

      - name: Create audit log
        if: always()
        run: |
          cd target-repo

          echo "üìù Creating audit log..."

          # Read package details
          published_list=""
          if [ -f published_packages.txt ] && [ -s published_packages.txt ]; then
            published_list=$(cat published_packages.txt | jq -R -s -c 'split("\n") | map(select(length > 0) | split("|") | {name: .[0], old_version: .[1], new_version: .[2], path: .[3]})')
          else
            published_list="[]"
          fi

          skipped_list=""
          if [ -f skipped_packages.txt ] && [ -s skipped_packages.txt ]; then
            skipped_list=$(cat skipped_packages.txt | jq -R -s -c 'split("\n") | map(select(length > 0) | split("|") | {name: .[0], status: .[1], reason: .[2]})')
          else
            skipped_list="[]"
          fi

          # Create audit log with jq (safe from injection)
          jq -n \
            --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            --arg workflow_run_id "${{ github.run_id }}" \
            --arg repository "${{ env.PAYLOAD_REPOSITORY }}" \
            --arg commit_sha "${{ env.PAYLOAD_COMMIT_SHA }}" \
            --arg commit_message "${{ env.PAYLOAD_COMMIT_MESSAGE }}" \
            --arg commit_author "${{ env.PAYLOAD_COMMIT_AUTHOR }}" \
            --arg branch "${{ env.PAYLOAD_BRANCH }}" \
            --argjson published "${{ env.published || 0 }}" \
            --argjson skipped "${{ env.skipped || 0 }}" \
            --arg registry "$UPM_REGISTRY" \
            --argjson published_packages "$published_list" \
            --argjson skipped_packages "$skipped_list" \
            '{
              timestamp: $timestamp,
              workflow_run_id: $workflow_run_id,
              source_repository: $repository,
              commit: {
                sha: $commit_sha,
                message: $commit_message,
                author: $commit_author,
                branch: $branch
              },
              results: {
                published: $published,
                skipped: $skipped
              },
              registry: $registry,
              published_packages: $published_packages,
              skipped_packages: $skipped_packages
            }' > audit-log.json

          echo "‚úÖ Audit log created"
          cat audit-log.json

      - name: Upload audit log
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: audit-log-${{ github.run_id }}
          path: target-repo/audit-log.json
          retention-days: ${{ env.AUDIT_RETENTION_DAYS }}

      - name: Send Discord notification - Success
        if: env.published > 0
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK_UPM }}
          DISCORD_THREAD_ID: "1437635998509957181"
        run: |
          cd target-repo

          if [ -z "$DISCORD_WEBHOOK" ]; then
            echo "‚ö†Ô∏è  DISCORD_WEBHOOK_UPM secret not set, skipping notification"
            exit 0
          fi

          # Define URLs early for use in truncated message
          workflow_url="https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          repository="${{ env.PAYLOAD_REPOSITORY }}"
          commit_sha="${{ env.PAYLOAD_COMMIT_SHA }}"
          commit_short="${commit_sha:0:7}"
          commit_url="https://github.com/$repository/commit/$commit_sha"
          timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)

          # Build detailed package information from tracking file
          # Limit to 10 packages to avoid Discord's 6000 char limit
          package_details=""
          package_count=0
          total_packages=0
          MAX_PACKAGES_SHOWN=10

          if [ -f published_packages.txt ] && [ -s published_packages.txt ]; then
            # Count total packages first
            total_packages=$(wc -l < published_packages.txt | tr -d ' ')

            while IFS='|' read -r name old_ver new_ver package_path; do
              [ -z "$name" ] && continue
              package_count=$((package_count + 1))

              # Only show first MAX_PACKAGES_SHOWN packages in detail
              if [ "$package_count" -le "$MAX_PACKAGES_SHOWN" ]; then
                # Build CHANGELOG.md URL (using master branch for persistent links)
                changelog_url="https://github.com/$repository/blob/master/$package_path/CHANGELOG.md"
                registry_url="https://upm.the1studio.org/-/web/detail/$name"

                # Determine version change type
                if [ "$old_ver" = "0.0.0" ]; then
                  # New package
                  line="### üÜï **$name**"$'\n'
                  line="${line}‚î£‚îÅ **Version:** \`$new_ver\` _(new package)_"$'\n'
                  line="${line}‚î£‚îÅ [Registry]($registry_url)"$'\n'
                  line="${line}‚îó‚îÅ [Changelog]($changelog_url)"
                else
                  # Version upgrade - determine type
                  IFS='.' read -r old_major old_minor old_patch <<< "$old_ver"
                  IFS='.' read -r new_major new_minor new_patch <<< "$new_ver"

                  if [ "$new_major" != "$old_major" ]; then
                    change_type="üî¥ **MAJOR**"
                    emoji="üöÄ"
                  elif [ "$new_minor" != "$old_minor" ]; then
                    change_type="üü° **MINOR**"
                    emoji="‚ú®"
                  else
                    change_type="üü¢ **PATCH**"
                    emoji="üîß"
                  fi

                  line="### $emoji **$name**"$'\n'
                  line="${line}‚î£‚îÅ **Version:** \`$old_ver\` ‚ûú \`$new_ver\`"$'\n'
                  line="${line}‚î£‚îÅ **Change Type:** $change_type"$'\n'
                  line="${line}‚î£‚îÅ [Registry]($registry_url)"$'\n'
                  line="${line}‚îó‚îÅ [Changelog]($changelog_url)"
                fi

                if [ -z "$package_details" ]; then
                  package_details="$line"
                else
                  package_details="$package_details\n\n$line"
                fi
              fi
            done < published_packages.txt

            # Add summary if more packages than shown
            if [ "$total_packages" -gt "$MAX_PACKAGES_SHOWN" ]; then
              remaining=$((total_packages - MAX_PACKAGES_SHOWN))
              package_details="$package_details\n\n---\n\n_üì¶ **And $remaining more package(s)**_\n_View full list in [workflow run]($workflow_url)_"
            fi
          else
            package_details="No packages published"
          fi

          # Build skipped packages summary if any
          skipped_summary=""
          if [ -f skipped_packages.txt ] && [ -s skipped_packages.txt ]; then
            skipped_count=$(wc -l < skipped_packages.txt | tr -d ' ')
            if [ "$skipped_count" -gt 0 ]; then
              skipped_summary="‚è≠Ô∏è  **$skipped_count packages skipped** (already published)"
            fi
          fi

          # Construct beautiful Discord embed with jq
          jq -n \
            --arg package_details "$package_details" \
            --arg skipped_summary "$skipped_summary" \
            --arg published "${{ env.published }}" \
            --arg skipped "${{ env.skipped }}" \
            --arg repository "$repository" \
            --arg commit_message "${{ env.PAYLOAD_COMMIT_MESSAGE }}" \
            --arg commit_author "${{ env.PAYLOAD_COMMIT_AUTHOR }}" \
            --arg commit_url "$commit_url" \
            --arg commit_short "$commit_short" \
            --arg workflow_url "$workflow_url" \
            --arg timestamp "$timestamp" \
            '{
              "embeds": [{
                "author": {
                  "name": "UPM Auto Publisher",
                  "icon_url": "https://raw.githubusercontent.com/github/explore/80688e429a7d4ef2fca1e82350fe8e3517d3494d/topics/npm/npm.png"
                },
                "title": "üì¶ Package Published Successfully",
                "description": ("üè¢ **Repository:** [`" + $repository + "`](https://github.com/" + $repository + ")\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"),
                "color": 5763719,
                "fields": [
                  {
                    "name": "üìã Published Packages",
                    "value": $package_details,
                    "inline": false
                  },
                  {
                    "name": "üìä Publishing Summary",
                    "value": ("‚úÖ **Published:** " + $published + " package(s)\n" + if $skipped_summary != "" then $skipped_summary else "" end),
                    "inline": false
                  },
                  {
                    "name": "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
                    "value": "",
                    "inline": false
                  },
                  {
                    "name": "üí¨ Commit Details",
                    "value": ("[`" + $commit_short + "`](" + $commit_url + ") " + $commit_message + "\nüë§ **Author:** " + $commit_author),
                    "inline": false
                  },
                  {
                    "name": "üîó Links",
                    "value": ("üìã [Workflow Run](" + $workflow_url + ")\nüì¶ [Registry](https://upm.the1studio.org)"),
                    "inline": false
                  }
                ],
                "thumbnail": {
                  "url": "https://raw.githubusercontent.com/github/explore/80688e429a7d4ef2fca1e82350fe8e3517d3494d/topics/unity/unity.png"
                },
                "timestamp": $timestamp,
                "footer": {
                  "text": "UPM Auto Publisher ‚Ä¢ The1Studio",
                  "icon_url": "https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png"
                }
              }]
            }' > discord_payload.json

          # Send to Discord (with thread_id as query parameter)
          curl -X POST "$DISCORD_WEBHOOK?thread_id=$DISCORD_THREAD_ID" \
            -H "Content-Type: application/json" \
            -d @discord_payload.json \
            --fail --silent --show-error || echo "‚ö†Ô∏è  Failed to send Discord notification"

          rm -f discord_payload.json

      - name: Send Discord notification - Failure
        if: failure()
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK_UPM }}
          DISCORD_THREAD_ID: "1437635998509957181"
        run: |
          if [ -z "$DISCORD_WEBHOOK" ]; then
            echo "‚ö†Ô∏è  DISCORD_WEBHOOK_UPM secret not set, skipping notification"
            exit 0
          fi

          workflow_url="https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          repository="${{ env.PAYLOAD_REPOSITORY }}"
          timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)

          jq -n \
            --arg repository "$repository" \
            --arg workflow_url "$workflow_url" \
            --arg timestamp "$timestamp" \
            '{
              "embeds": [{
                "author": {
                  "name": "UPM Auto Publisher",
                  "icon_url": "https://raw.githubusercontent.com/github/explore/80688e429a7d4ef2fca1e82350fe8e3517d3494d/topics/npm/npm.png"
                },
                "title": "‚ùå Package Publishing Failed",
                "description": ("üè¢ **Repository:** [`" + $repository + "`](https://github.com/" + $repository + ")\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"),
                "color": 15158332,
                "fields": [
                  {
                    "name": "‚ö†Ô∏è Failure Details",
                    "value": "The workflow execution failed during package publishing.\n\n**Action Required:**\n‚Ä¢ Check the workflow logs for error details\n‚Ä¢ Review package.json configurations\n‚Ä¢ Verify registry connectivity\n‚Ä¢ Check npm authentication",
                    "inline": false
                  },
                  {
                    "name": "üîó Links",
                    "value": ("üìã [View Workflow Logs](" + $workflow_url + ")\nüì¶ [Registry](https://upm.the1studio.org)"),
                    "inline": false
                  }
                ],
                "thumbnail": {
                  "url": "https://raw.githubusercontent.com/github/explore/80688e429a7d4ef2fca1e82350fe8e3517d3494d/topics/unity/unity.png"
                },
                "timestamp": $timestamp,
                "footer": {
                  "text": "UPM Auto Publisher ‚Ä¢ The1Studio",
                  "icon_url": "https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png"
                }
              }]
            }' > discord_payload_error.json

          curl -X POST "$DISCORD_WEBHOOK?thread_id=$DISCORD_THREAD_ID" \
            -H "Content-Type: application/json" \
            -d @discord_payload_error.json \
            --fail --silent --show-error || echo "‚ö†Ô∏è  Failed to send Discord notification"

          rm -f discord_payload_error.json

      - name: Cleanup
        if: always()
        run: |
          echo "üßπ Cleaning up..."
          cd ..
          rm -rf target-repo
          echo "‚úÖ Cleanup complete"
