name: Trigger Publishing for Stale Packages

on:
  schedule:
    - cron: '0 12 * * *'  # Daily at noon UTC (after cache built)

  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run (report only, do not trigger workflows)'
        type: boolean
        default: true

permissions:
  contents: read

jobs:
  trigger-publishes:
    runs-on: [self-hosted, arc, the1studio, org]
    timeout-minutes: 30
    name: Trigger publishing workflows for stale packages
    outputs:
      stale_count: ${{ steps.find_stale.outputs.stale_count }}
      triggered: ${{ steps.trigger_stats.outputs.triggered }}
      not_ready: ${{ steps.trigger_stats.outputs.not_ready }}
      no_dispatch: ${{ steps.trigger_stats.outputs.no_dispatch }}
      failed: ${{ steps.trigger_stats.outputs.failed }}
      dry_run: ${{ inputs.dry_run }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Install dependencies
        run: |
          # Fix APT sources to use HTTPS instead of HTTP (port 80 blocked)
          sudo sed -i 's|http://archive.ubuntu.com|https://archive.ubuntu.com|g' /etc/apt/sources.list
          sudo sed -i 's|http://security.ubuntu.com|https://security.ubuntu.com|g' /etc/apt/sources.list

          # Disable PPA repositories
          sudo mv /etc/apt/sources.list.d /etc/apt/sources.list.d.bak 2>/dev/null || true
          sudo mkdir -p /etc/apt/sources.list.d

          sudo apt-get update -qq
          sudo apt-get install -y -qq jq

      - name: Find stale packages
        id: find_stale
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          echo "üîç Finding packages with version mismatches..."
          echo ""

          # Check if cache exists
          if [ ! -f config/package-cache.json ]; then
            echo "‚ùå Cache not found. Run build-package-cache workflow first."
            exit 1
          fi

          # Check cache age
          cache_updated=$(jq -r '.updated' config/package-cache.json)
          cache_age=$(( ($(date +%s) - $(date -d "$cache_updated" +%s 2>/dev/null || echo 0)) / 3600 ))

          echo "Cache age: $cache_age hours"

          if [ "$cache_age" -gt 12 ]; then
            echo "‚ö†Ô∏è  Cache is stale (>12 hours old)"
            echo "   Consider running build-package-cache workflow first"
          fi

          # Find packages where current version != published version
          stale_count=0
          rm -f /tmp/stale_packages.txt

          while IFS= read -r repo_entry; do
            repo_name=$(echo "$repo_entry" | jq -r '.key')

            # Process each package in this repository
            while IFS= read -r pkg_entry; do
              pkg_name=$(echo "$pkg_entry" | jq -r '.key')
              pkg_data=$(echo "$pkg_entry" | jq -r '.value')

              path=$(echo "$pkg_data" | jq -r '.path')
              current=$(echo "$pkg_data" | jq -r '.version')
              published=$(echo "$pkg_data" | jq -r '.publishedVersion // "not-published"')

              # Only process if versions differ and package was published before
              if [ "$current" != "$published" ] && [ "$published" != "not-published" ]; then
                echo "üì¶ $pkg_name"
                echo "   Repository: $repo_name"
                echo "   Path: $path"
                echo "   Current: $current"
                echo "   Published: $published"
                echo "   Status: ‚ö†Ô∏è Needs publishing"
                echo ""

                # Save to file for next step
                echo "$pkg_name|$repo_name|$path|$current|$published" >> /tmp/stale_packages.txt

                stale_count=$((stale_count + 1))
              fi
            done < <(echo "$repo_entry" | jq -c '.value.packages | to_entries[]')
          done < <(jq -c '.repositories | to_entries[]' config/package-cache.json)

          if [ "$stale_count" -eq 0 ]; then
            echo "‚úÖ All packages are up to date!"
            echo "stale_count=0" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "Found $stale_count package(s) needing publishing"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

          echo "stale_count=$stale_count" >> $GITHUB_OUTPUT

      - name: Trigger publishing workflows
        id: trigger_stats
        if: steps.find_stale.outputs.stale_count > 0 && inputs.dry_run != true
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          echo "üöÄ Triggering publishing workflows..."
          echo ""

          triggered=0
          failed=0
          no_dispatch=0
          not_ready=0

          while IFS='|' read -r pkg_name repo path current published; do
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "üì¶ $pkg_name"
            echo "   Repository: $repo"
            echo "   Current: $current ‚Üí Published: $published"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

            # Check if workflow exists
            if ! gh api "repos/$repo/actions/workflows/publish-upm.yml" >/dev/null 2>&1; then
              echo "   ‚ö†Ô∏è  Workflow not deployed yet in $repo"
              echo "   Skipping (will be deployed via register-repos workflow)..."
              not_ready=$((not_ready + 1))
              echo ""
              continue
            fi

            # Check if workflow has workflow_dispatch trigger
            workflow_content=$(gh api "repos/$repo/contents/.github/workflows/publish-upm.yml" \
              --jq '.content' 2>/dev/null | base64 -d 2>/dev/null || echo "")

            if ! echo "$workflow_content" | grep -q "workflow_dispatch:"; then
              echo "   ‚ö†Ô∏è  Workflow doesn't have workflow_dispatch trigger"
              echo "   This workflow needs to be updated with workflow_dispatch"
              echo ""
              echo "   To fix: The register-repos workflow will update it on next run"
              echo ""
              ((no_dispatch++))
              continue
            fi

            # Trigger the workflow
            echo "   üöÄ Triggering workflow..."

            if gh workflow run publish-upm.yml \
              --repo "$repo" \
              --ref master 2>&1 || gh workflow run publish-upm.yml \
              --repo "$repo" \
              --ref main 2>&1; then
              echo "   ‚úÖ Workflow triggered successfully!"
              echo "   üìä Check status: https://github.com/$repo/actions/workflows/publish-upm.yml"
              ((triggered++))
            else
              echo "   ‚ùå Failed to trigger workflow"
              ((failed++))
            fi

            echo ""
            sleep 2  # Rate limit protection

          done < /tmp/stale_packages.txt

          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "üìä Summary"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "‚úÖ Triggered: $triggered"
          echo "üîß Not Ready (workflow not deployed): $not_ready"
          echo "‚ö†Ô∏è  Missing workflow_dispatch: $no_dispatch"
          echo "‚ùå Failed: $failed"
          echo ""

          if [ "$not_ready" -gt 0 ]; then
            echo "üí° To deploy workflows to repositories:"
            echo "   Run the register-repos workflow to deploy publish-upm.yml"
          fi

          if [ "$no_dispatch" -gt 0 ]; then
            echo "üí° To fix missing workflow_dispatch:"
            echo "   Workflows will be updated automatically on next register-repos run"
            echo "   Or manually add 'workflow_dispatch:' to the workflow file"
          fi

          # Save stats for summary and outputs
          echo "triggered=$triggered" >> $GITHUB_ENV
          echo "not_ready=$not_ready" >> $GITHUB_ENV
          echo "no_dispatch=$no_dispatch" >> $GITHUB_ENV
          echo "failed=$failed" >> $GITHUB_ENV

          echo "triggered=$triggered" >> $GITHUB_OUTPUT
          echo "not_ready=$not_ready" >> $GITHUB_OUTPUT
          echo "no_dispatch=$no_dispatch" >> $GITHUB_OUTPUT
          echo "failed=$failed" >> $GITHUB_OUTPUT

      - name: Summary
        if: always()
        run: |
          stale_count="${{ steps.find_stale.outputs.stale_count }}"

          echo "# üöÄ Publish Trigger Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Date**: $(date -u +%Y-%m-%d\ %H:%M:%S)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "$stale_count" = "0" ] || [ -z "$stale_count" ]; then
            echo "‚úÖ **All packages are up to date!**" >> $GITHUB_STEP_SUMMARY
            exit 0
          fi

          echo "## Stale Packages Found: $stale_count" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ -f /tmp/stale_packages.txt ]; then
            echo "| Package | Repository | Current | Published |" >> $GITHUB_STEP_SUMMARY
            echo "|---------|-----------|---------|-----------|" >> $GITHUB_STEP_SUMMARY

            while IFS='|' read -r pkg_name repo path current published; do
              echo "| \`$pkg_name\` | $repo | \`$current\` | \`$published\` |" >> $GITHUB_STEP_SUMMARY
            done < /tmp/stale_packages.txt

            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          if [ "${{ inputs.dry_run }}" = "true" ]; then
            echo "---" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "‚ö†Ô∏è **Dry run mode** - No workflows were triggered" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "To actually trigger workflows, run with \`dry_run: false\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "---" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## Results" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ **Triggered**: ${{ env.triggered }}" >> $GITHUB_STEP_SUMMARY
            echo "- üîß **Not Ready** (workflow not deployed): ${{ env.not_ready }}" >> $GITHUB_STEP_SUMMARY
            echo "- ‚ö†Ô∏è **Missing workflow_dispatch**: ${{ env.no_dispatch }}" >> $GITHUB_STEP_SUMMARY
            echo "- ‚ùå **Failed**: ${{ env.failed }}" >> $GITHUB_STEP_SUMMARY
          fi

  notify-discord:
    runs-on: [self-hosted, arc, the1studio, org]
    needs: trigger-publishes
    if: always()
    steps:
      - name: Send Discord notification
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK_UPM }}
          DISCORD_THREAD_ID: "1437635998509957181"
        run: |
          if [ -z "$DISCORD_WEBHOOK" ]; then
            echo "‚ö†Ô∏è  DISCORD_WEBHOOK_UPM secret not set, skipping notification"
            exit 0
          fi

          # Determine status emoji and color
          status="${{ needs.trigger-publishes.result }}"
          if [ "$status" == "success" ]; then
            status_emoji="‚úÖ"
            color=4764443  # Green
          elif [ "$status" == "failure" ]; then
            status_emoji="‚ùå"
            color=15158332  # Red
          else
            status_emoji="‚ö†Ô∏è"
            color=16776960  # Yellow
          fi

          workflow_url="https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          cache_url="https://github.com/${{ github.repository }}/blob/master/config/package-cache.json"
          dry_run="${{ needs.trigger-publishes.outputs.dry_run }}"
          mode_text=$([ "$dry_run" == "true" ] && echo "‚ö†Ô∏è Dry Run" || echo "üöÄ Live Run")
          timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)

          stale_count="${{ needs.trigger-publishes.outputs.stale_count || '0' }}"
          triggered="${{ needs.trigger-publishes.outputs.triggered || '0' }}"
          not_ready="${{ needs.trigger-publishes.outputs.not_ready || '0' }}"
          no_dispatch="${{ needs.trigger-publishes.outputs.no_dispatch || '0' }}"
          failed="${{ needs.trigger-publishes.outputs.failed || '0' }}"

          # Build triggers section
          if [ "$dry_run" != "true" ]; then
            triggers_value="[\`\`\`\nTriggered:  $triggered\nNot Ready:  $not_ready\nNo Dispatch: $no_dispatch\nFailed:     $failed\n\`\`\`]"
          else
            triggers_value="‚ö†Ô∏è **Dry Run Mode** - No workflows triggered"
          fi

          jq -n \
            --arg status_emoji "$status_emoji" \
            --argjson color "$color" \
            --arg workflow_url "$workflow_url" \
            --arg cache_url "$cache_url" \
            --arg mode_text "$mode_text" \
            --arg stale_count "$stale_count" \
            --arg triggers_value "$triggers_value" \
            --arg timestamp "$timestamp" \
            '{
              "embeds": [{
                "author": {
                  "name": "UPM Auto Publisher",
                  "icon_url": "https://raw.githubusercontent.com/github/explore/80688e429a7d4ef2fca1e82350fe8e3517d3494d/topics/npm/npm.png"
                },
                "title": ($status_emoji + " Trigger Stale Package Publishing"),
                "description": "üöÄ **Workflow:** Trigger Stale Publishes\n‚è∞ **Schedule:** Daily at noon UTC\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
                "color": $color,
                "fields": [
                  {
                    "name": "‚öôÔ∏è Mode",
                    "value": $mode_text,
                    "inline": true
                  },
                  {
                    "name": "üìä Stale Packages Found",
                    "value": $stale_count,
                    "inline": true
                  },
                  {
                    "name": "üöÄ Publish Triggers",
                    "value": $triggers_value,
                    "inline": false
                  },
                  {
                    "name": "üîó Quick Links",
                    "value": ("[üìã Workflow Run](" + $workflow_url + ") ‚Ä¢ [üíæ Package Cache](" + $cache_url + ")"),
                    "inline": false
                  }
                ],
                "footer": {
                  "text": "THE 1 GAME STUDIO",
                  "icon_url": "https://raw.githubusercontent.com/The1Studio/UPMAutoPublisher/master/.github/assets/the1studio-logo.png"
                },
                "timestamp": $timestamp
              }]
            }' > discord_payload.json

          # Send to Discord (with thread_id as query parameter)
          curl -X POST "$DISCORD_WEBHOOK?thread_id=$DISCORD_THREAD_ID" \
            -H "Content-Type: application/json" \
            -d @discord_payload.json \
            --fail --silent --show-error || echo "‚ö†Ô∏è  Failed to send Discord notification"

          rm -f discord_payload.json
